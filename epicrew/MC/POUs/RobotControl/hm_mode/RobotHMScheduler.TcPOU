<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="RobotHMScheduler" Id="{a9daa94b-52e0-4f1f-8fa5-2d8256a51797}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RobotHMScheduler
VAR_OUTPUT
END_VAR
VAR
	_robot_state : robot_hm_states_t:=robot_hm_states_t.END;
	_robot_direction: LINT;
	_rotation_angle: LINT;
	
	_robot_interface_adr: POINTER TO RobotInterface;
	_motor_interface_adr: POINTER TO ARRAY[0..1] OF MotorInterface;
	_motor_pp_scheduler_adr: POINTER TO ARRAY[0..1] OF MotorPPScheduler;
	_motor_hm_scheduler_adr: POINTER TO ARRAY[0..1] OF MotorHMScheduler;
	_motor_csp_scheduler_adr: POINTER TO ARRAY[0..1] OF MotorCSPScheduler;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF(_robot_interface_adr^.robot_mode=robot_modes_t.HM AND _robot_interface_adr^.robot_enabled) THEN
CASE _robot_state OF
	robot_hm_states_t.START:
		_motor_interface_adr^[0].driver_enable:=TRUE;
		_motor_interface_adr^[1].driver_enable:=TRUE;
		_motor_interface_adr^[0].base_current:=70;
		_motor_interface_adr^[1].base_current:=70;
		_motor_pp_scheduler_adr^[0].update_pp_parameter(profile_velocity:=30000,profile_acceleration:=5000);
		_motor_pp_scheduler_adr^[1].update_pp_parameter(profile_velocity:=30000,profile_acceleration:=5000);
		_motor_pp_scheduler_adr^[0].activate();
		_motor_pp_scheduler_adr^[1].activate();
		_motor_pp_scheduler_adr^[0].start_operation(target_position:=500_000, change_immediately:=FALSE,reference_coordinate:=TRUE,push_operation:=FALSE);
		_motor_pp_scheduler_adr^[1].start_operation(target_position:=-500_000, change_immediately:=FALSE,reference_coordinate:=TRUE,push_operation:=FALSE);
		_robot_interface_adr^.robot_reset_fault:=FALSE;
		_robot_state := robot_hm_states_t.RETRACT;
	robot_hm_states_t.RETRACT:
		IF(	(_motor_interface_adr^[0].driver_state=driver_states_t.Fault OR _motor_interface_adr^[0].driver_state=driver_states_t.FaultReactionActive) AND
			(_motor_interface_adr^[1].driver_state=driver_states_t.Fault OR _motor_interface_adr^[1].driver_state=driver_states_t.FaultReactionActive)) THEN
			_robot_interface_adr^.robot_reset_fault:=TRUE;
			_robot_state := robot_hm_states_t.RESETTING_FAULT;
		END_IF
	robot_hm_states_t.RESETTING_FAULT:
		IF(	_motor_interface_adr^[0].driver_state<>driver_states_t.Fault AND _motor_interface_adr^[0].driver_State<>driver_states_t.FaultReactionActive AND
			_motor_interface_adr^[1].driver_state<>driver_states_t.Fault AND _motor_interface_adr^[1].driver_state<>driver_states_t.FaultReactionActive) THEN
			_robot_interface_adr^.robot_reset_fault:=FALSE;
			_motor_interface_adr^[0].base_current:=1000;
			_motor_interface_adr^[1].base_current:=1000;
			_motor_pp_scheduler_adr^[0].start_operation(target_position:=-20000, change_immediately:=TRUE,reference_coordinate:=TRUE,push_operation:=FALSE);
			_motor_pp_scheduler_adr^[1].start_operation(target_position:=20000, change_immediately:=TRUE,reference_coordinate:=TRUE,push_operation:=FALSE);
			_robot_state := robot_hm_states_t.RELEASE;
		END_IF
	robot_hm_states_t.RELEASE:
		IF(_motor_pp_scheduler_adr^[0].get_state()=motor_pp_states_t.END AND _motor_pp_scheduler_adr^[1].get_state()=motor_pp_states_t.END) THEN
			_robot_direction:= TO_LINT(_motor_interface_adr^[0].feedback_position + _motor_interface_adr^[1].feedback_position)/2;
			_rotation_angle:=LREAL_TO_LINT(TO_LREAL(_robot_direction)/1_000_000)*1_000_000 - _robot_direction;
			_motor_pp_scheduler_adr^[0].start_operation(target_position:=_rotation_angle, change_immediately:=TRUE,reference_coordinate:=TRUE,push_operation:=FALSE);
			_motor_pp_scheduler_adr^[1].start_operation(target_position:=_rotation_angle, change_immediately:=TRUE,reference_coordinate:=TRUE,push_operation:=FALSE);
			_robot_state := robot_hm_states_t.ROTATE;
		END_IF
	robot_hm_states_t.ROTATE:
		IF(_motor_pp_scheduler_adr^[0].get_state()=motor_pp_states_t.END AND _motor_pp_scheduler_adr^[1].get_state()=motor_pp_states_t.END) THEN
			_motor_hm_scheduler_adr^[0].activate();
			_motor_hm_scheduler_adr^[1].activate();
			_motor_hm_scheduler_adr^[0].start_operation();
			_motor_hm_scheduler_adr^[1].start_operation();
			_robot_state := robot_hm_states_t.HOME;
		END_IF
	robot_hm_states_t.HOME:
		IF(_motor_hm_scheduler_adr^[0].get_state() = motor_hm_states_t.END AND _motor_hm_scheduler_adr^[1].get_state()=motor_hm_states_t.END) THEN
			_robot_state := robot_hm_states_t.END;
			_motor_interface_adr^[0].reset_position();
			_motor_interface_adr^[1].reset_position();
		END_IF
END_CASE
END_IF]]></ST>
    </Implementation>
    <Method Name="activate" Id="{7054f0e8-5193-40c9-914b-743a6d48e6e7}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD activate : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_interface_adr^.robot_mode:=robot_modes_t.HM;
_robot_state:=robot_hm_states_t.END;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{cc2340a5-130f-42dd-9187-3f388eb41eea}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	robot_interface_adr: POINTER TO RobotInterface;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_interface_adr:=robot_interface_adr;
_motor_pp_scheduler_adr:=robot_interface_adr^.motor_pp_scheduler_adr;
_motor_hm_scheduler_adr:=robot_interface_adr^.motor_hm_scheduler_adr;
_motor_csp_scheduler_adr:=robot_interface_adr^.motor_csp_scheduler_adr;
_motor_interface_adr:=robot_interface_adr^.motor_interface_adr;]]></ST>
      </Implementation>
    </Method>
    <Method Name="get_state" Id="{8e3cbeda-689a-4f72-8ef6-172f538d1d69}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD get_state : robot_hm_states_t
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[get_state:=_robot_state;]]></ST>
      </Implementation>
    </Method>
    <Method Name="start_operation" Id="{a4c63f12-8d02-4762-a118-93b0b6358dcd}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD start_operation : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_interface_adr^.robot_enabled:=TRUE;
_robot_state := robot_hm_states_t.START;]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RobotHMScheduler">
      <LineId Id="1196" Count="53" />
      <LineId Id="298" Count="0" />
    </LineIds>
    <LineIds Name="RobotHMScheduler.activate">
      <LineId Id="6" Count="0" />
      <LineId Id="10" Count="0" />
    </LineIds>
    <LineIds Name="RobotHMScheduler.FB_init">
      <LineId Id="55" Count="3" />
      <LineId Id="16" Count="0" />
    </LineIds>
    <LineIds Name="RobotHMScheduler.get_state">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RobotHMScheduler.start_operation">
      <LineId Id="10" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>