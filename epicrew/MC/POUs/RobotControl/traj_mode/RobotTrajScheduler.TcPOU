<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="RobotTrajScheduler" Id="{3475d739-c2ce-403d-9d4d-ad34a855fb1e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK RobotTrajScheduler
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	_robot_interface_adr: POINTER TO RobotInterface;
	_motor_interface_adr: POINTER TO ARRAY[0..1] OF MotorInterface;
	_motor_pp_scheduler_adr: POINTER TO ARRAY[0..1] OF MotorPPScheduler;
	_motor_hm_scheduler_adr: POINTER TO ARRAY[0..1] OF MotorHMScheduler;
	_motor_csp_scheduler_adr: POINTER TO ARRAY[0..1] OF MotorCSPScheduler;
	
	_target_motor_angles : ARRAY[0..1] OF DINT;
	_robot_state: robot_traj_states_t :=robot_traj_states_t.END;
	_robot_trajectory_extension_adr : POINTER TO ARRAY [0..1000000] OF LREAL;
	_robot_trajectory_rotation_adr :  POINTER TO ARRAY [0..1000000] OF LREAL;
	
	_robot_fb_motor_1_adr : POINTER TO ARRAY [0..1_000_000] OF LINT;
	_robot_fb_motor_2_adr : POINTER TO ARRAY [0..1_000_000] OF LINT;
	_robot_tg_motor_1_adr : POINTER TO ARRAY [0..1_000_000] OF LINT;
	_robot_tg_motor_2_adr : POINTER TO ARRAY [0..1_000_000] OF LINT;
	
	_robot_trajectory_length: DINT;
	_robot_trajectory_index:DINT;
END_VAR
VAR_STAT
END_VAR
VAR_IN_OUT
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF _robot_interface_adr^.robot_mode=robot_modes_t.CSP AND _robot_interface_adr^.robot_enabled THEN
	CASE _robot_state OF
		robot_traj_states_t.START:
			_motor_pp_scheduler_adr^[0].activate();
			_motor_pp_scheduler_adr^[1].activate();
			InverseKinematics(target_dist:=_robot_trajectory_extension_adr^[0],
							  target_angle:=_robot_trajectory_rotation_adr^[0],
							  motor_axis1_angle=>_target_motor_angles[0],
							  motor_axis2_angle=>_target_motor_angles[1]);
			_motor_pp_scheduler_adr^[0].start_operation(target_position:=_target_motor_angles[0],
				change_immediately:=TRUE, reference_coordinate:=FALSE, push_operation:=FALSE);
			_motor_pp_scheduler_adr^[1].start_operation(target_position:=_target_motor_angles[1],
				change_immediately:=TRUE, reference_coordinate:=FALSE, push_operation:=FALSE);
			_robot_state := robot_traj_states_t.RESET;
		robot_traj_states_t.RESET:
			IF(_motor_pp_scheduler_adr^[0].get_state()=motor_pp_states_t.END AND _motor_pp_scheduler_adr^[1].get_state()=motor_pp_states_t.END) THEN
				_robot_state:=robot_traj_states_t.READY;
			END_IF
		robot_traj_states_t.TRIG:
			_motor_csp_scheduler_adr^[0].activate();
			_motor_csp_scheduler_adr^[1].activate();
			_motor_csp_scheduler_adr^[0].set_position(_target_motor_angles[0]);
			_motor_csp_scheduler_adr^[1].set_position(_target_motor_angles[1]);
			_robot_trajectory_index:=0;
			_robot_state:=robot_traj_states_t.EXEC;
		robot_traj_states_t.EXEC:
			IF(_robot_trajectory_index < _robot_trajectory_length) THEN
				InverseKinematics(	target_dist:=_robot_trajectory_extension_adr^[_robot_trajectory_index],
									target_angle:=_robot_trajectory_rotation_adr^[_robot_trajectory_index],
									motor_axis1_angle=>_target_motor_angles[0],
									motor_axis2_angle=>_target_motor_angles[1]);
				
				_robot_tg_motor_1_adr^[_robot_trajectory_index] := _target_motor_angles[0];
				_robot_tg_motor_2_adr^[_robot_trajectory_index] := _target_motor_angles[1];
				_robot_fb_motor_1_adr^[_robot_trajectory_index] := _motor_interface_adr^[0].feedback_position;
				_robot_fb_motor_2_adr^[_robot_trajectory_index] := _motor_interface_adr^[1].feedback_position;
				_motor_csp_scheduler_adr^[0].set_position(_target_motor_angles[0]);
				_motor_csp_scheduler_adr^[1].set_position(_target_motor_angles[1]);
				_robot_trajectory_index:=_robot_trajectory_index+1;
			ELSE
				_robot_state:=robot_traj_states_t.END;
			END_IF
		robot_traj_states_t.END:
			IF(_robot_trajectory_index < 1_000_000 AND _robot_trajectory_index < _robot_trajectory_length+1000) THEN
				_robot_tg_motor_1_adr^[_robot_trajectory_index] := _target_motor_angles[0];
				_robot_tg_motor_2_adr^[_robot_trajectory_index] := _target_motor_angles[1];
				_robot_fb_motor_1_adr^[_robot_trajectory_index] := _motor_interface_adr^[0].feedback_position;
				_robot_fb_motor_2_adr^[_robot_trajectory_index] := _motor_interface_adr^[1].feedback_position;
				_robot_trajectory_index:=_robot_trajectory_index+1;
			END_IF
	END_CASE
END_IF]]></ST>
    </Implementation>
    <Method Name="activate" Id="{b944515c-e8f5-4554-a62b-4a81ba8f2fe9}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD activate : BOOL
VAR_INPUT
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_interface_adr^.robot_mode:=robot_modes_t.CSP;
_robot_state:=robot_traj_states_t.END;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_init" Id="{e24df1fe-3b58-4bc5-b255-4a57701f8716}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start)
	bInCopyCode : BOOL;  // if TRUE, the instance afterwards gets moved into the copy code (online change)
	robot_interface_adr: POINTER TO RobotInterface;
	robot_trajectory_extension_adr : POINTER TO ARRAY [0..1000000] OF LREAL;
	robot_trajectory_rotation_adr :  POINTER TO ARRAY [0..1000000] OF LREAL;
	robot_fb_motor_1_adr : POINTER TO ARRAY [0..1_000_000] OF LREAL;
	robot_fb_motor_2_adr : POINTER TO ARRAY [0..1_000_000] OF LREAL;
	robot_tg_motor_1_adr : POINTER TO ARRAY [0..1_000_000] OF LREAL;
	robot_tg_motor_2_adr : POINTER TO ARRAY [0..1_000_000] OF LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_interface_adr:=robot_interface_adr;
_motor_pp_scheduler_adr:=robot_interface_adr^.motor_pp_scheduler_adr;
_motor_hm_scheduler_adr:=robot_interface_adr^.motor_hm_scheduler_adr;
_motor_csp_scheduler_adr:=robot_interface_adr^.motor_csp_scheduler_adr;
_motor_interface_adr:=robot_interface_adr^.motor_interface_adr;
_robot_trajectory_extension_adr := robot_trajectory_extension_adr;
_robot_trajectory_rotation_adr := robot_trajectory_rotation_adr;

	_robot_fb_motor_1_adr := robot_fb_motor_1_adr;
	_robot_fb_motor_2_adr := robot_fb_motor_2_adr;
	_robot_tg_motor_1_adr := robot_tg_motor_1_adr;
	_robot_tg_motor_2_adr := robot_tg_motor_2_adr;]]></ST>
      </Implementation>
    </Method>
    <Method Name="get_state" Id="{efa253c8-c6fd-4f2d-95e0-66bc113740ef}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD get_state : robot_traj_states_t
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[get_state:=_robot_state;]]></ST>
      </Implementation>
    </Method>
    <Method Name="set_trajectory_length" Id="{5b262864-fbca-453c-9e47-49cba5ea5555}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD set_trajectory_length : BOOL
VAR_INPUT
	robot_trajectory_length: DINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_trajectory_length:=robot_trajectory_length;]]></ST>
      </Implementation>
    </Method>
    <Method Name="start_operation" Id="{0fe91ea6-0b67-4794-bfe4-e3a2434247db}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD start_operation : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[_robot_interface_adr^.robot_enabled:=TRUE;
_robot_state:=robot_traj_states_t.START;
_robot_trajectory_index:=0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="trigger" Id="{d97718eb-bed6-4109-8d6e-22ed29b1e6b9}">
      <Declaration><![CDATA[{attribute 'TcRpcEnable'}
METHOD trigger : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF(_robot_state<>robot_traj_states_t.READY) THEN
	RETURN;
ELSE
	_robot_state:=robot_traj_states_t.TRIG;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="RobotTrajScheduler">
      <LineId Id="801" Count="12" />
      <LineId Id="857" Count="0" />
      <LineId Id="814" Count="9" />
      <LineId Id="880" Count="0" />
      <LineId Id="824" Count="5" />
      <LineId Id="911" Count="4" />
      <LineId Id="830" Count="3" />
      <LineId Id="882" Count="0" />
      <LineId Id="881" Count="0" />
      <LineId Id="916" Count="1" />
      <LineId Id="920" Count="2" />
      <LineId Id="918" Count="0" />
      <LineId Id="923" Count="0" />
      <LineId Id="919" Count="0" />
      <LineId Id="834" Count="0" />
      <LineId Id="23" Count="0" />
    </LineIds>
    <LineIds Name="RobotTrajScheduler.activate">
      <LineId Id="5" Count="0" />
      <LineId Id="7" Count="0" />
    </LineIds>
    <LineIds Name="RobotTrajScheduler.FB_init">
      <LineId Id="25" Count="3" />
      <LineId Id="7" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="52" Count="3" />
      <LineId Id="51" Count="0" />
    </LineIds>
    <LineIds Name="RobotTrajScheduler.get_state">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="RobotTrajScheduler.set_trajectory_length">
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="RobotTrajScheduler.start_operation">
      <LineId Id="14" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="RobotTrajScheduler.trigger">
      <LineId Id="5" Count="4" />
    </LineIds>
  </POU>
</TcPlcObject>